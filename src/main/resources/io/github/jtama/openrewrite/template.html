<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Project Aerial View</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            overflow: hidden;
        }

        .links line {
            stroke-opacity: 0.6;
        }

        .nodes circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
        }

        .node.selected {
            stroke: #000;
            stroke-width: 2px;
        }

        .node.fade, .links line.fade {
            opacity: 0.2;
        }

        .tooltip {
            z-index: 10;
            position: absolute;
            text-align: left;
            padding: 8px;
            font: 12px sans-serif;
            background: #eee;
            border: 1px solid #999;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .legend {
            z-index: 10;
            position: absolute;
            top: 20px;
            right: 20px;
            background: #fff;
            border: 1px solid #999;
            border-radius: 8px;
            padding: 10px;
            font: 12px sans-serif;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
        }

        .search {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 2em;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
        }

        input[type='range'] {
            height: 10px;
            border-radius: 10px;
            box-shadow: 0 1px 1px #def3f8, inset 0 0.125em 0.125em #0d1112;
        }
    </style>
</head>
<body>
<div class="search">
    <div>
        <label for="search">Search for class:</label>
        <input type="text" id="search" placeholder="className">
    </div>
    <div>
        <label for="size-chooser">Node size depends on :</label>
        <select type="text" id="size-chooser">
            <option value="incoming" selected="true">Incoming connections</option>
            <option value="outgoing">Outgoing connections</option>
        </select>
    </div>
    <div>
        <label for="color-chooser">Node color depends on :</label>
        <select type="text" id="color-chooser">
            <option value="louvain" selected="true">Louvain calculated community</option>
            <option value="artifactId">Project artefact identifier</option>
        </select>
    </div>
    <div>
        <label for="weight-filter">Filter nodes who weight more than :</label>
        <input type="range" id="weight-filter" min="0" max="100" step="1">
        <span id="weight-value">100</span>
    </div>
    <div>
        <label for="color-number">Number of communities with color :</label>
        <input type="range" id="color-number" min="0" max="30" step="1">
        <span id="color-number-value" style="margin-left: 5px;">100</span>
    </div>
</div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script type="module">
    import jLouvain from 'https://cdn.jsdelivr.net/npm/jlouvain@2.0.0/+esm'

    const originalGraphData = JSON.parse(''{{graphData}}'');
    let currentNodes = originalGraphData.nodes;
    let currentLinks = originalGraphData.links;
    let color;
    let communityCenters = {};

    const width = window.innerWidth;
    const height = window.innerHeight;

    // --- Tooltip ---
    const tooltip = d3.select("body").append("div")
        .attr("class", "tooltip");

    // --- Legend Container ---
    const legend = d3.select("body").append("div")
        .attr("class", "legend");

    const simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(d => d.className).distance(100))
        .force("charge", d3.forceManyBody().strength(-50))
        .force("center", d3.forceCenter(width / 2, height / 2))
        // Add community clustering forces
        .force("x", d3.forceX(d => communityCenters[d.community]?.x || width / 2).strength(0.05))
        .force("y", d3.forceY(d => communityCenters[d.community]?.y || height / 2).strength(0.05));

    const svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);


    const defs = svg.append("defs");

    const allGradients = [];

    let allLinks = svg.append("g")
        .attr("class", "links")
        .selectAll("line");

    let allNodes = svg.append("g")
        .attr("class", "nodes")
        .selectAll("circle");

    let selectedNode = null;

    let sizeExtractor = node => node.incomingConnections;

    let communityMethod = 'louvain';

    let myZoom = d3.zoom().on('zoom', handleZoom);
    initZoom();

    // --- Dynamic Range Slider Setup ---
    const allSizes = originalGraphData.nodes.map(d => d.size);
    const minSize = d3.min(allSizes) || 0;
    const maxSize = d3.max(allSizes) || 100;
    const allColors = ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080', '#ffffff', '#000000'];
    let currentColors = allColors.slice();

    const weightSlider = d3.select("#weight-filter");
    const sizeChooser = d3.select("#size-chooser");
    const colorChooser = d3.select("#color-chooser");
    const weightValueSpan = d3.select("#weight-value");

    weightSlider
        .attr("min", minSize)
        .attr("max", maxSize)
        .attr("value", maxSize);
    weightValueSpan.text(maxSize);

    const colorSlider = d3.select("#color-number");
    const colorValueSpan = d3.select("#color-number-value");

    colorSlider
        .attr("min", 5)
        .attr("max", 30)
        .attr("value", 30);
    colorValueSpan.text(30);

    d3.select("#search").on("input", function () {
        const searchTerm = this.value.toLowerCase();
        allNodes.style("opacity", n => n.className.toLowerCase().includes(searchTerm) ? 1 : 0.1);
        allLinks.style("opacity", l => l.source.className.toLowerCase().includes(searchTerm) || l.target.className.toLowerCase().includes(searchTerm) ? 1 : 0.1);
    });

    sizeChooser.on("input", function () {
        if (this.value === "incoming") {
            sizeExtractor = node => node.incomingConnections;
        } else {
            sizeExtractor = node => node.outgoingConnections;
        }
        updateVisualization();
    })

    colorChooser.on("input", function () {
        communityMethod = this.value;
        calculateCommunities(currentNodes, currentLinks); // Recalculate communities
        updateLegend(currentNodes); // Update legend with new community assignments
        updateVisualization();
    })

    weightSlider.on("input", function () {
        const maxWeight = +this.value;
        weightValueSpan.text(maxWeight); // Update the displayed value

        const filteredNodes = originalGraphData.nodes
            .filter(n => sizeExtractor(n) <= maxWeight)
        const filteredNodeIds = new Set(filteredNodes.map(n => n.className));
        const filteredLinks = originalGraphData.links
            .filter(l => filteredNodeIds.has(l.source.className) && filteredNodeIds.has(l.target.className))
            .map(({source, target, incomingConnections, outgoingConnections}) => ({
                source: source.className,
                target: target.className,
                incomingConnections,
                outgoingConnections
            }));

        currentNodes = filteredNodes;
        currentLinks = filteredLinks;

        // Recalculate communities and update legend on the filtered data
        calculateCommunities(currentNodes, currentLinks);
        updateLegend(currentNodes);
        updateVisualization();
    });

    colorSlider.on("input", function () {
        const colorNumber = +this.value;
        colorValueSpan.text(colorNumber); // Update the displayed value

        currentColors = allColors.slice(0, colorNumber)

        updateLegend(currentNodes);
        updateVisualization();
    });

    // Initial setup
    calculateCommunities(currentNodes, currentLinks);
    updateLegend(currentNodes);
    updateVisualization();


    function clickHandler(event, d) {
        if (selectedNode === d) {
            selectedNode = null;
            allLinks.classed('fade', false);
        } else {
            selectedNode = d;
            const linkedNodes = new Set();
            linkedNodes.add(d.className);
            currentLinks.forEach(l => {
                if (l.source === d.className) linkedNodes.add(l.target);
                if (l.target === d.className) linkedNodes.add(l.source);
            });
            allLinks.classed('fade', l => l.source !== d.className && l.target !== d.className);
        }
    }

    function dblClickHandler(event, d) {
        if (d.fx === null) {
            d.fx = d.x;
            d.fy = d.y;

        } else {
            d.fx = null;
            d.fy = null;
        }
    }

    function calculateCommunities(nodes, links) {
        let community
        if(communityMethod === 'louvain') {
            const nodeData = nodes.map(d => d.className);
            const linkData = links.map(l => ({source: l.source, target: l.target, weight: l.weight || 1}));
            if (nodeData.length === 0) return;

            const community = jLouvain.jLouvain().nodes(nodeData).edges(linkData);
            const communityResult = community();

            nodes.forEach(node => {
                node.community = communityResult[node.className];
            });
        } else {
            nodes.forEach(node => {
                node.community = node.artifactId;
            });
        }


    }

    function updateLegend(nodes) {
        let allCommunities = nodes.reduce((acc, item) => {
            acc[item.community] = acc[item.community] || {community: item.community, weight: 0};
            acc[item.community].weight++;
            return acc;
        }, {});

        allCommunities = Object.values(allCommunities);
        allCommunities.sort((a, b) => b.weight - a.weight);
        allCommunities = allCommunities.slice(0, 30);

        color = allCommunities.reduce((map, item, index) => {
            map[item.community] = {item, color: currentColors[index] || '#9E9E9E'};
            return map;
        }, {});


        legend.selectAll("*").remove(); // Clear existing legend

        const legendItems = legend.selectAll(".legend-item")
            .data(allCommunities)
            .enter().append("div")
            .attr("class", "legend-item");

        legendItems.append("div")
            .attr("class", "legend-color")
            .style("background-color", d => color[d.community].color);

        legendItems.append("input")
            .attr("type", "checkbox")
            .attr("checked", true)
            .on("change", (event, d) => {
                const visible = event.target.checked;
                d3.selectAll(".nodes circle").filter(n => n.community === d.community).style("display", visible ? "block" : "none");
            });

        legendItems.append("span").text(d => `Community ${d.community}`);
    }

    function updateVisualization() {
        // Update nodes
        allNodes = allNodes
            .data(currentNodes, d => d.className)
            .join(
                enter => enter.append("circle")
                    .attr("r", d => 5 + sizeExtractor(d) / 2)
                    .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended))
                    .on("mouseover", function (event, d) {
                        tooltip.style("opacity", .9);
                        tooltip.html(`ID: ${d.className}<br/>Incoming connections: ${d.incomingConnections}<br/>Outgoing connections: ${d.outgoingConnections}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function (d) {
                        tooltip.style("opacity", 0);
                    })
                    .on('click', clickHandler)
                    .on('dblclick', dblClickHandler),
                update => update,
                exit => exit.remove()
            )
            .attr("fill", d => (color[d.community] ? color[d.community].color : '#9E9E9E')); // Apply color to both enter and update selections, with a fallback for communities not in the top 30

        // Update links
        allLinks = allLinks
            .data(currentLinks, d => `${d.source}-${d.target}`)
            .join(
                enter => enter.append("line")
                    .attr("stroke-width", d => 1 + Math.sqrt(d.weight))
                    .on("mouseover", function (event, d) {
                        tooltip.style("opacity", .9);
                        tooltip.html(`Source: ${d.source}<br/>Target: ${d.target}<br/>Interactions: ${d.weight}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function (d) {
                        tooltip.style("opacity", 0);
                    }),
                update => update,
                exit => exit.remove()
            )
            .attr("stroke", d => { // Apply stroke to both enter and update selections
                const sourceNode = currentNodes.find(n => n.className === d.source);
                const targetNode = currentNodes.find(n => n.className === d.target);
                if (!sourceNode || !targetNode) return "#ccc";

                const id = `gradient-${sourceNode.community}-${targetNode.community}`.replace(/[^a-zA-Z0-9]/g, "-");
                if (!allGradients.some(item => item.attr('id') === id)) {
                    const gradient = defs.append("linearGradient")
                        .attr("id", id)
                        .attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", color[sourceNode.community].color);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", color[targetNode.community].color);
                    allGradients.push(gradient);
                }
                return `url(#${id})`;
            });

        // Update simulation
        simulation.nodes(currentNodes)
        simulation.force("link").links(currentLinks)
        simulation.alpha(1).restart();
        simulation.on("tick", ticked);
    }


    function ticked() {


        allNodes
            .attr("r", d => 5 + sizeExtractor(d) / 2)
            .attr("cx", d => {
                const radius = 5 + sizeExtractor(d) / 2;
                return d.x = Math.max(radius, Math.min(width - radius, d.x));
            })
            .attr("cy", d => {
                const radius = 5 + sizeExtractor(d) / 2;
                return d.y = Math.max(radius, Math.min(height - radius, d.y));
            });

        allLinks
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);
    }

    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function handleZoom(e) {
        allLinks.attr('transform', e.transform);
        allNodes.attr('transform', e.transform);
    }

    function initZoom() {
        svg.call(myZoom);
    }
</script>
</body>
</html>